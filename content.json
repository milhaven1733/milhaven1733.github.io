[{"title":"test","date":"2017-04-19T04:30:19.000Z","path":"2017/04/19/test/","text":"","tags":[]},{"title":"利用udacity学生数据集实践数据分析过程","date":"2017-04-19T03:22:06.000Z","path":"2017/04/19/利用udacity学生数据集实践数据分析过程/","text":"利用udacity学生数据集实践数据分析过程数据采集与清理数据分析中的数据来源 下载数据文件 从API中获取 从网页收集 合并多种不同格式数据 在这次实践中，我们采用下载数据文件的方式。（将课程提供的三个csv数据集下载至本地) 接下来，需要对数据文件进行数据整理使数据能够用于分类及分析。 就要先了解我们下载的csv文件。 关于CSV Comma Separated Values——逗号分隔值 易于通过代码处理（相比.xlsx） csv文件的表格与文本格式: Python中的CSVcsv文件内容通常呈现为一系列行 每行为一个列表，整体数据结构为包含一系列列表的列表 1csv=[[&apos;A1&apos;,&apos;A2&apos;,&apos;A3&apos;],[&apos;B1&apos;,&apos;B2&apos;,&apos;B3&apos;]] 每行为一个字典，整体数据结构为包含一系列字典的列表（标题行的每个关键词为键，每个字段作为值。） 1csv=[&#123;&apos;name1&apos;:&apos;A1&apos;,&apos;name2&apos;:&apos;A2&apos;,&apos;name3&apos;:&apos;A3&apos;&#125;,&#123;&apos;name1&apos;:&apos;B1&apos;,&apos;name2&apos;:&apos;B2&apos;,&apos;name3&apos;:&apos;B3&apos;&#125;] Python unicodecsv库 123456789import unicodecsvenrollments=[]f=open(&apos;/home/milhaven1733/enrollments.csv&apos;,&apos;rb&apos;)reader=unicodecsv.DictReader(f)for row in reader: enrollments.append(row)f.close()enrollments[0] 输出： 1234567&#123;u&apos;account_key&apos;: u&apos;448&apos;, u&apos;cancel_date&apos;: u&apos;2015-01-14&apos;, u&apos;days_to_cancel&apos;: u&apos;65&apos;, u&apos;is_canceled&apos;: u&apos;True&apos;, u&apos;is_udacity&apos;: u&apos;True&apos;, u&apos;join_date&apos;: u&apos;2014-11-10&apos;, u&apos;status&apos;: u&apos;canceled&apos;&#125; 运用DictReader方法将csv文件每行转化为字典并生成一个迭代器（注意迭代器只能一次用于循环一次。） 优化代码： 12345import unicodecsvwith open(&apos;/home/milhaven1733/enrollments.csv&apos;,&apos;rb&apos;) as f: reader=unicodecsv.DictReader(f) enrollments=list(reader)enrollments[0] 利用list方法不使用循环生成列表 分别读取所需的三个csv文件： 12345678import unicodecsv def read_csv(filename): with open(filename, &apos;rb&apos;) as f: reader = unicodecsv.DictReader(f) return list(reader)enrollments = read_csv(&apos;/home/milhaven1733/enrollments.csv&apos;)daily_engagement = read_csv(&apos;/home/milhaven1733/daily_engagement.csv&apos;)project_submissions = read_csv(&apos;/home/milhaven1733/project_submissions.csv&apos;) 修正数据类型从生成的字典列表中可以看出，unicodecsv处理时并不区分数据类型，需要根据实际使用来转换数据类型。（最好在获取数据之初就进行转换以免遗忘） 修正enrollments： 1234567&#123;u&apos;account_key&apos;: u&apos;448&apos;, u&apos;cancel_date&apos;: u&apos;2015-01-14&apos;, u&apos;days_to_cancel&apos;: u&apos;65&apos;, u&apos;is_canceled&apos;: u&apos;True&apos;, u&apos;is_udacity&apos;: u&apos;True&apos;, u&apos;join_date&apos;: u&apos;2014-11-10&apos;, u&apos;status&apos;: u&apos;canceled&apos;&#125; 12345678910111213141516171819from datetime import datetime as dtdef parse_date(date): if date==&apos;&apos;: return None else: return dt.strptime(date,&apos;%Y-%m-%d&apos;) def parse_int(i): if i==&apos;&apos;: return None else: return int(i)for enrollment in enrollments: enrollment[&apos;join_date&apos;]=parse_date(enrollment[&apos;join_date&apos;]) enrollment[&apos;cancel_date&apos;]=parse_date(enrollment[&apos;cancel_date&apos;]) enrollment[&apos;days_to_cancel&apos;]=parse_int(enrollment[&apos;days_to_cancel&apos;]) enrollment[&apos;is_udacity&apos;]=enrollment[&apos;is_udacity&apos;]==&apos;True&apos; enrollment[&apos;is_canceled&apos;]=enrollment[&apos;is_canceled&apos;]==&apos;True&apos; 运用datetime.strptime转换时间格式 修正Project_submissions： 123456&#123;u&apos;account_key&apos;: u&apos;256&apos;, u&apos;assigned_rating&apos;: u&apos;UNGRADED&apos;, u&apos;completion_date&apos;: u&apos;2015-01-16&apos;, u&apos;creation_date&apos;: u&apos;2015-01-14&apos;, u&apos;lesson_key&apos;: u&apos;3176718735&apos;, u&apos;processing_state&apos;: u&apos;EVALUATED&apos;&#125; 123for submission in project_submissions: submission[&apos;creation_date&apos;]=parse_date(submission[&apos;creation_date&apos;]) submission[&apos;completion_date&apos;]=parse_date(submission[&apos;completion_date&apos;]) 修正daily_engagement： 123456&#123;u&apos;acct&apos;: u&apos;0&apos;, u&apos;lessons_completed&apos;: u&apos;0.0&apos;, u&apos;num_courses_visited&apos;: u&apos;1.0&apos;, u&apos;projects_completed&apos;: u&apos;0.0&apos;, u&apos;total_minutes_visited&apos;: u&apos;11.6793745&apos;, u&apos;utc_date&apos;: u&apos;2015-01-09&apos;&#125; 123456for engagement in daily_engagement: engagement[&apos;lessons_completed&apos;]=int(float(engagement[&apos;lessons_completed&apos;])) engagement[&apos;num_courses_visited&apos;]=int(float(engagement[&apos;num_courses_visited&apos;])) engagement[&apos;projects_completed&apos;]=int(float(engagement[&apos;projects_completed&apos;])) engagement[&apos;total_minutes_visited&apos;]=float(engagement[&apos;total_minutes_visited&apos;]) engagement[&apos;utc_date&apos;]=parse_date(engagement[&apos;utc_date&apos;]) 先将包含小数点的字符串转化为float再转化为int 对处理好的数据集提出疑问数据集处理完成后需要针对数据提出疑问，如： 通常需要多久提交项目？ 通过和未通过项目的学生有什么区别？ 学员上课的平均时间 上课时间、数量与完成项目之间的关系 参与度随时间的改变 通过项目前提交的次数 等。 本次探究针对问题：通过与未通过首个项目的学生参与课程的差异。 整理数据成功加载数据并确保数据格式良好，说明你已经开始数据整理过程了。下一步就是调查，看看数据中是否存在不一致处或问题，如果有，则需要清理它们。 可以在每个数据表中查找不重复学员数，并创建一组帐号列表：（以处理enrollments列表为例） 1234unique_enrollment=[]for enrollment in enrollments: unique_enrollment.append(enrollment[&apos;account_key&apos;])unique_enrollment=set(unique_enrollment) 用set(list)达到去重目的。 修正数据表中的问题enrollments表与daily_engagement表中，表示学员账户的键名称不同，可能会对之后的数据处理及分析产生影响，怎么修改能使之保持一致？ 123for engagement_record in daily_engagement: engagement_record[&apos;account_key&apos;] = engagement_record[&apos;acct&apos;] del[engagement_record[&apos;acct&apos;]] 修改后，亦可创建函数方便实现上个话题中三个数据表分别清理重复学员账户的问题。 缺失的参与记录从之前的学员账户统计结果可以看出，enrollments表与daily_engagement表中，’account_key‘的数量不同，为什么部分注册用户没有参与记录呢？ 我们可以找出缺失参与记录的注册用户，对其特点展开探究： 123for enrollment in enrollments: if enrollment[&apos;account_key&apos;] not in unique_engagement: print enrollment 通过遍历enrollments表，查找缺失参与记录的用户。大体可以发现： 缺失记录的用户，大多在同一天注册与注销。 （即可能只有账户存在时长超过一天，才会存在参与记录） 核查更多问题记录我们上面找到的原因是造成部分用户缺失参与记录的全部原因吗？是否存在其他原因？可以对缺失参与记录的注册用户展开进一步探究： 123for enrollment in enrollments: if enrollment[&apos;account_key&apos;] not in unique_engagement and enrollment[&apos;join_date&apos;] != enrollment[&apos;cancel_date&apos;]: print enrollment 剩余问题对上个问题中存在的另外3个异常用户展开探究，发现其’is_udacity‘的值为True，即为系统的测试用户——找到了问题。 接下来，我们需要排除数据集中的测试用户，以避免对之后分析的干扰。 首先，创建测试用户集合： 12345test_account=[]for enrollment in enrollments: if enrollment[&apos;is_udacity&apos;]: test_account.append(enrollment[&apos;account_key&apos;])test_account=set(test_account) 创建从数据集中清理测试用户的函数： 123456def remove_uda_acc(data): non_uda_data=[] for data_point in data: if data_point[&apos;account_key&apos;] not in test_account: non_uda_data.append(data_point) return non_uda_data 执行函数，创建不包含测试用户的新数据集： 123non_uda_enrollments=remove_uda_acc(enrollments)non_uda_engagement=remove_uda_acc(daily_engagement)non_uda_submissions=remove_uda_acc(project_submissions) 提炼问题目前，想探究的问题： 对于通过和未通过第一个项目的学员，他们在daily_engagement表中的数据有何不同？ 目前整理出的数据集对于探究这个问题存在的缺陷： 提交后的参与数据与项目无关 可能会对比不同时间段的参与数据（参与度受时间影响） 参与数据包含不属于第一个项目的课程 对策：（针对前两个问题） 只查看学生注册前一周的数据，并排除一周内注销的用户。 针对以上方案，可以首先：创建未注销或注销前注册时长超过七天的学生字典paid_students 对于字典：Key：’account_key‘, Value:enrollment_date 创建过程如下： 12345678paid_student=&#123;&#125;for enrollment in non_uda_enrollments: if (not enrollment[&apos;is_canceled&apos;]) or (enrollment[&apos;days_to_cancel&apos;]&gt;7): account_key=enrollment[&apos;account_key&apos;] enrollment_date=enrollment[&apos;join_date&apos;] if(account_key not in paid_student or enrollment_date&gt;paid_student[account_key]): paid_student[account_key]=enrollment_date 由于一个学生可能多次注册，仅在account_key不存在，或enrollment_date比原注册日期更晚时才添加数据，可以保证保存的的是最近的注册日期。 获取第一周数据创建新列表，存储paid_students中学生注册一周内的参与数据： 首先，移除各数据集中注册时长小于一周的学生数据（即account_key未在paid_students中的数据） 12345678910def remove_free_trial_cancels(data): new_data = [] for data_point in data: if data_point[&apos;account_key&apos;] in paid_students: new_data.append(data_point) return new_datapaid_enrollments = remove_free_trial_cancels(non_udacity_enrollments)paid_engagement = remove_free_trial_cancels(non_udacity_engagement)paid_submissions = remove_free_trial_cancels(non_udacity_submissions) 创建检测参与时间是否在注册一周内的函数： 123def within_one_week(join_date, engagement_date): time_delta = engagement_date - join_date return time_delta.days &lt; 7 最后，创建新列表并存储符合要求的数据：（利用上述函数进行检验） 12345678paid_engagement_in_first_week = []for engagement_record in paid_engagement: account_key = engagement_record[&apos;account_key&apos;] join_date = paid_students[account_key] engagement_record_date = engagement_record[&apos;utc_date&apos;] if within_one_week(join_date, engagement_record_date): paid_engagement_in_first_week.append(engagement_record) 对参与度的探索怎样探索某学员第一周上课的平均时间？ 可以将搜娱的参与记录按学员账户分组存入字典，每组包含某学生的所有参与记录 key:account_key Value:engagement_table 123456from collections import defaultdict #允许设置默认值的字典engagement_by_account=defaultdict(list) #当在字典中寻找商不存在的关键字，会得到一个空列表。for engagement_record in paid_engagement_in_first_week: account_key=engagement_record[&apos;account_key&apos;] engagement_by_account[account_key].append(engagement_record) 运行代码后，一周内参与数据已分组存入字典。 接下来，可以另设一字典，存入某学生一周内学习的总时长 Key:account_key Value:total_minutes 123456total_minutes_by_account=&#123;&#125;for account_key,engagement_for_student in engagement_by_account.items(): total_minutes=0 for engagement_record in engagement_for_student: total_minutes+=engagement_record[&apos;total_minutes_visited&apos;] total_minutes_by_account[account_key]=total_minutes 得到了包含所有学员一周内学习时长的字典，可以通过dict.values()方法，将字典中所有value导入一列表，引入numpy库，进行简单的分析： 123456total_minutes=total_minutes_by_account.values()import numpy as npprint &apos;Mean:&apos;,np.mean(total_minutes)print &apos;Standard deviation:&apos;,np.std(total_minutes)print &apos;Min:&apos;,np.min(total_minutes)print &apos;Max:&apos;,np.max(total_minutes) 从输出结果： 1234Mean: 647.590173826Standard deviation: 1129.27121042Min: 0.0Max: 10568.1008673 #（异常值） 可以看出，数据存在一定的问题，需要进一步地探究。 寻找异常所在我们可以从学习时长最大的account入手，寻找数据采集是否存在问题。 首先，查找max_minutes对应的max_account: 12345max_minutes=0for account_key,total_minutes in total_minutes_by_account.items(): if total_minutes&gt;max_minutes: max_minutes=total_minutes max_account=account_key 在一周参与记录中查找该账户对应的记录以及该账户的注册信息： 1234for engagement in paid_engagement_in_first_week: if engagement[&apos;account_key&apos;]==max_account: print engagementprint paid_student[max_account] 从输出结果看到条目远远大于7条，即收集的参与数据包含了学员最新一次注册之前的所有数据，检查可发现，是检测参与时间是否在注册一周内的函数出现问题，加以更正： 123def within_one_week(join_date, engagement_date): time_delta = engagement_date - join_date return time_delta.days &lt; 7 and time_delta.days&gt;=0 重新运行其下代码，在新的数据集中进行简要分析，得到结果： 1234Mean: 306.708326753Standard deviation: 412.996933409Min: 0.0Max: 3564.7332645 虽然Max值接近60小时，但较为可信。 可以执行本节中前两段代码再次检测最大值对应用户的参与记录，核验是否仍存在问题。 探索课程完成情况怎样探索学员第一周完成的课程数量？ 利用目前已经得到的某学员一周内参与记录，我们可以用类似得到上课时长的方式得到完成课程数量。 由于代码相似度非常高，可以定义几个函数，完成类似的内容，如： 123456789101112131415def sum_grouped_items(grouped_data, field_name): summed_data = &#123;&#125; for account_key,engagement_for_student in grouped_data.items(): total=0 for engagement_record in engagement_for_student: total+=engagement_record[field_name] summed_data[account_key]=total return summed_data import numpy as npdef describe_data(data): print &apos;Mean:&apos;, np.mean(data) print &apos;Standard deviation:&apos;, np.std(data) print &apos;Minimum:&apos;, np.min(data) print &apos;Maximum:&apos;, np.max(data) 得到某学员某项指标总值的函数，与简要分析包含所有学员某项总值的列表的函数 进行分析: 1234total_minutes_by_account=sum_grouped_items(engagement_by_account,&apos;total_minutes_visited&apos;)lessons_completed=sum_grouped_items(engagement_by_account,&apos;lessons_completed&apos;)describe_data(total_minutes_by_account.values())describe_data(lessons_completed.values()) 为增强运算灵活性，也可以在这里将按学员account_key分组得到某学员参与数据的代码重写为函数并执行： 12345678from collections import defaultdict #允许设置默认值的字典def group_data(data,key_name): grouped_data=defaultdict(list) #当在字典中寻找商不存在的关键字，会得到一个空列表。 for data_point in data: key=data_point[key_name] grouped_data[key].append(data_point) return grouped_dataengagement_by_account=group_data(paid_engagement_in_first_week,&apos;account_key&apos;) 探索一周访问天数怎样可以得到学员每周访问课程的天数？ 从记录中可以看出，学员某日记录的‘num_courses_visited’字段不同。大于0说明当日访问了课程，等于0则说明没有访问，我们可以为记录新增加’has_visited’字段，来记录当天是否访问，再调用上节的各个函数，就可以计算一周内访问天数的总和以及对所有访问天数进行分析了。 为paid_engagement（所有注册时间长于一周的学员的记录）添加’has_visited’字段： 12345for engagement in paid_engagement: if engagement[&apos;num_courses_visited&apos;]&gt;0: engagement[&apos;has_visited&apos;]=1 else: engagement[&apos;has_visited&apos;]=0 进行统计和分析： 12total_visited=sum_grouped_items(engagement_by_account,&apos;has_visited&apos;)describe_data(total_visited.values()) 划分学员参与记录现在继续正题，以是否通过第一个项目为标准，将学员划分为两组，同时也将参与记录划分为两组。 首先查看一条提交记录： 1234567paid_submissions[0]:&#123;u&apos;account_key&apos;: u&apos;256&apos;, u&apos;assigned_rating&apos;: u&apos;UNGRADED&apos;, u&apos;completion_date&apos;: datetime.datetime(2015, 1, 16, 0, 0), u&apos;creation_date&apos;: datetime.datetime(2015, 1, 14, 0, 0), u&apos;lesson_key&apos;: u&apos;3176718735&apos;, u&apos;processing_state&apos;: u&apos;EVALUATED&apos;&#125; ‘lesson_key’字段指示提交项目的代码 ‘assigned_rating’字段指示项目是否通过 而首个项目的’lesson_key’为’746169184’ 或 ‘3176718735’ 表示通过项目的状态为：’PASSED’或’DISTINCTION’ 可以执行以下代码，将所有通过第一个项目的学员的account_key 加入pass_subway_project列表： 123456789subway_project_lesson_keys = [&apos;746169184&apos;, &apos;3176718735&apos;]rating_passed=[&apos;PASSED&apos;,&apos;DISTINCTION&apos;]pass_subway_project = set()for submission in paid_submissions: account_key=submission[&apos;account_key&apos;] lesson_key=submission[&apos;lesson_key&apos;] assigned_rating=submission[&apos;assigned_rating&apos;] if (lesson_key in subway_project_lesson_keys) and (assigned_rating in rating_passed): pass_subway_project.add(account_key) 再以account_key是否在pass_subway_project列表中为标准划分参与记录： 1234567passing_engagement = []non_passing_engagement = []for engagement_record in paid_engagement_in_first_week: if engagement_record[&apos;account_key&apos;] in pass_subway_project: passing_engagement.append(engagement_record) else: non_passing_engagement.append(engagement_record) 比较两组学员现在可以调用之间group_data与统计、分析函数，新创建两个包含某学员参与数据的字典并进行通过与未通过项目的学员参与数据之间统计与比较： 1234567891011121314151617181920212223242526272829passing_engagement_by_account = group_data(passing_engagement,&apos;account_key&apos;)non_passing_engagement_by_account = group_data(non_passing_engagement,&apos;account_key&apos;)print &apos;total_minutes_visited:&apos;print &apos;non-passing students:&apos;non_passing_minutes = sum_grouped_items(non_passing_engagement_by_account,&apos;total_minutes_visited&apos;)describe_data(non_passing_minutes.values())print &apos;\\npassing students:&apos;passing_minutes = sum_grouped_items(passing_engagement_by_account,&apos;total_minutes_visited&apos;)describe_data(passing_minutes.values())print &apos;\\n\\nlessons_completed:&apos;print &apos;non-passing students:&apos;non_passing_lessons = sum_grouped_items(non_passing_engagement_by_account,&apos;lessons_completed&apos;)describe_data(non_passing_lessons.values())print &apos;\\npassing students:&apos;passing_lessons = sum_grouped_items(passing_engagement_by_account,&apos;lessons_completed&apos;)describe_data(passing_lessons.values())print &apos;\\n\\nhas_visited:&apos;print &apos;non-passing students:&apos;non_passing_visits = sum_grouped_items(non_passing_engagement_by_account,&apos;has_visited&apos;)describe_data(non_passing_visits.values())print &apos;\\npassing students:&apos;passing_visits = sum_grouped_items(passing_engagement_by_account,&apos;has_visited&apos;)describe_data(passing_visits.values()) 输出结果： 12345678910111213141516171819202122232425262728293031323334353637383940total_minutes_visited:non-passing students:Mean: 143.326474267Standard deviation: 269.538619011Minimum: 0.0Maximum: 1768.52274933passing students:Mean: 394.586046484Standard deviation: 448.499519327Minimum: 0.0Maximum: 3564.7332645lessons_completed:non-passing students:Mean: 0.862068965517Standard deviation: 2.54915994183Minimum: 0Maximum: 27passing students:Mean: 2.05255023184Standard deviation: 3.14222705558Minimum: 0Maximum: 36has_visited:non-passing students:Mean: 1.90517241379Standard deviation: 1.90573144136Minimum: 0Maximum: 7passing students:Mean: 3.38485316847Standard deviation: 2.25882147092Minimum: 0Maximum: 7 可对以上分析结果自行进行比较探究。 创建直方图对于上述6个统计结果，可以创建图表加以描述。 jupyter notebook创建直方图： 1234data = [1, 2, 1, 3, 3, 1, 4, 2]%matplotlib inline #设定图表在notebook内部输出import matplotlib.pyplot as pltplt.hist(data) 得到以下图表： 关于hist参数 参照示例创建描述及绘图函数： 123456789101112%matplotlib inlineimport matplotlib.pyplot as pltimport numpy as npdef describe_data(data,bins,x_label,y_label,title): print &apos;Mean:&apos;, np.mean(data) print &apos;Standard deviation:&apos;, np.std(data) print &apos;Minimum:&apos;, np.min(data) print &apos;Maximum:&apos;, np.max(data) plt.hist(data,bins) plt.xlabel(x_label) plt.ylabel(y_label) plt.title(title) 首先对比两组学生的听课总时长分布： 1234describe_data(non_passing_minutes.values(),50, &apos;Time/minutes&apos;,&apos;Number of people&apos;,r&apos;non_passing_students_total_minutes&apos;)describe_data(passing_minutes.values(),50, &apos;Time/minutes&apos;,&apos;Number of people&apos;,r&apos;passing_students_total_minutes&apos;) 得到图像： 对比发现，分布形状大致类似，但通过项目的学生组持续较长听课时间的人数要明显多于未通过组。 然后对比两组完成课程数量的分布： 1234describe_data(non_passing_lessons.values(),54, &apos;Lessons&apos;,&apos;Number of people&apos;,r&apos;non_passing_students_lessons&apos;)describe_data(passing_lessons.values(),72, &apos;Lessons&apos;,&apos;Number of people&apos;,r&apos;non_passing_students_lessons&apos;) 发现：虽然第一周两组内都是未听课的人数居多，但通过组听课量保持在1-10节的人数明显多于未通过组。 最后对比两组访问课程天数： 1234describe_data(non_passing_visits.values(),20, &apos;Visits/days&apos;,&apos;Number of people&apos;,r&apos;non_passing_students_visits&apos;)describe_data(passing_visits.values(),20, &apos;Visits/days&apos;,&apos;Number of people&apos;,r&apos;passing_students_visits&apos;) 这次的图形外形差异很大： 对与未通过组，随着天数增多，人数逐渐减少，而通过组，各个访问天数内人数相差不大。 是否能得到结论？通过以上对变量间联系的探究，我们可以做出一些预测或初步结论： 如：通过第一个项目的学生上课分钟数要多于未通过的学生。 但是，两组间的差异是真实存在的差异还是偶然造成（或受一些隐含因素影响）的呢？ 要得到确切的结论，还需要严格的统计学检查，否则得到的只是未经证实的试验性结论。 占坑 之后会写一篇应用独立样本t检验来验证相关性的笔记 关于相关性与因果性相关性：通过第一个项目的学生更愿意在第一周内多听课 因果性：在第一周内更多上课可以使学生通过第一个项目 两者之间有非常大的不同，如果想要验证因果关系，可以进行A/B测试 基于众多特征进行预测通过以上的整理分析，现在可以尝试预测：哪些学生更可能通过首个项目？ 可以运用启发式方法（heuristics） 也可以利用机器学习，自动进行较为准确的预测。 改善图形分享心得在得出结论和做出预测后，需要分享研究结果、进行交流。 但如果想以可视化的方法呈现结果，最好可以对图形加以优化，使其更美观、更能表现图表想要传达的内容。 如，可以添加坐标轴名称，图表标题，改变bins参数设置直方图所使用的分组数量等优化图表 还可以使用 seaborn 库自动美化 matplotlib 图形。 即在代码中导入此库： 1import seaborn as sns 在此后创建的图形就会自动进行美化。 优化后的效果 至此，我们较为完整地完成了一个数据分析的流程，但还有许多不完善的地方有待加以补充。","tags":[]},{"title":"MySQL-学习笔记-3","date":"2017-04-16T01:23:42.000Z","path":"2017/04/16/MySQL-学习笔记-3/","text":"MySQL约束及修改数据表外键约束的要求解析约束 根据约束针对字段多少： 针对一个字段——列级约束 针对多个字段——表级约束 外键约束 注：当外键列无索引时，MySQL自动创建索引，而当参照列无索引时，不会自动创建。 查看MySQL当前提供引擎 1mysql&gt; show engines; 查看MySQL默认存储引擎 123456789mysql&gt; show variables like &apos;%storage_engine%&apos;;+----------------------------------+--------+| Variable_name | Value |+----------------------------------+--------+| default_storage_engine | InnoDB || default_tmp_storage_engine | InnoDB || disabled_storage_engines | || internal_tmp_disk_storage_engine | InnoDB |+----------------------------------+--------+ 创建父表： 1234mysql&gt; CREATE TABLE provinces( -&gt; id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, -&gt; pname VARCHAR(20) NOT NULL -&gt; ); 查看创建父表时的存储引擎： 12345678910mysql&gt; SHOW CREATE TABLE provinces;+-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| provinces | CREATE TABLE `provinces` ( `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT, `pname` varchar(20) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1 |+-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 创建子表（错误示例） 1234567mysql&gt; CREATE TABLE user( -&gt; id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, -&gt; username VARCHAR(10) NOT NULL, -&gt; pid BIGINT, -&gt; FOREIGN KEY (pid) REFERENCES provinces (id) -&gt; );ERROR 1215 (HY000): Cannot add foreign key constraint 可见，外键列必须与主键保持相同数据类型 创建子表： 123456mysql&gt; CREATE TABLE users( -&gt; id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, -&gt; username VARCHAR(10) NOT NULL, -&gt; pid SMALLINT UNSIGNED, -&gt; FOREIGN KEY (pid) REFERENCES provinces (id) -&gt; ); 查看子表创建时的引擎和外键的创建： 12345678910111213mysql&gt; SHOW CREATE TABLE users;+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| users | CREATE TABLE `users` ( `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(10) NOT NULL, `pid` smallint(5) unsigned DEFAULT NULL, PRIMARY KEY (`id`), KEY `pid` (`pid`), CONSTRAINT `users_ibfk_1` FOREIGN KEY (`pid`) REFERENCES `provinces` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1 |+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 查看父表索引： 123456789101112131415mysql&gt; SHOW INDEXES FROM provinces\\G*************************** 1. row *************************** Table: provinces Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment: Index_comment: 可见：参照列 ‘id’ 为主键，已自动创建索引 \\G表示以网格形式显示 查看子表索引 1234567891011121314151617181920212223242526272829mysql&gt; SHOW INDEXES FROM users\\G*************************** 1. row *************************** Table: users Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment: Index_comment: *************************** 2. row *************************** Table: users Non_unique: 1 Key_name: pid Seq_in_index: 1 Column_name: pid Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: YES Index_type: BTREE Comment: Index_comment: 可见，子表存在两个索引：子表主键的索引以及外键的索引 外键约束的参照操作 创建子表，指定外键的参照操作： 123456mysql&gt; CREATE TABLE user1( -&gt; id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, -&gt; username VARCHAR(10) NOT NULL, -&gt; pid SMALLINT UNSIGNED, -&gt; FOREIGN KEY (pid) REFERENCES provinces (id) ON DELETE CASCADE -&gt; ); 在父表中插入记录 1234567891011121314151617mysql&gt; INSERT provinces(pname) VALUE(&apos;A&apos;);Query OK, 1 row affected (0.06 sec)mysql&gt; INSERT provinces(pname) VALUE(&apos;B&apos;);Query OK, 1 row affected (0.04 sec)mysql&gt; INSERT provinces(pname) VALUE(&apos;C&apos;);Query OK, 1 row affected (0.09 sec)mysql&gt; SELECT * FROM provinces;+----+-------+| id | pname |+----+-------+| 1 | A || 2 | B || 3 | C |+----+-------+ 在子表中插入记录 12mysql&gt; INSERT user1(username,pid) VALUES(&apos;Tom&apos;,3);Query OK, 1 row affected (0.03 sec) 12mysql&gt; INSERT user1(username,pid) VALUES(&apos;John&apos;,5);ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`lcyDB`.`user1`, CONSTRAINT `user1_ibfk_1` FOREIGN KEY (`pid`) REFERENCES `provinces` (`id`) ON DELETE CASCADE) 可见：外键列不能设为父表中参照列不存在的值 123456789101112mysql&gt; INSERT user1(username,pid) VALUES(&apos;John&apos;,1);Query OK, 1 row affected (0.05 sec)mysql&gt; INSERT user1(username,pid) VALUES(&apos;Rose&apos;,2);Query OK, 1 row affected (0.05 sec)mysql&gt; SELECT * FROM user1;+----+----------+------+| id | username | pid |+----+----------+------+| 1 | Tom | 3 || 4 | John | 1 || 5 | Rose | 2 |+----+----------+------+ 删除父表中某记录，查看子表相应行是否改变： 123456789mysql&gt; DELETE FROM provinces WHERE id=3;Query OK, 1 row affected (0.05 sec)mysql&gt; SELECT * FROM user1;+----+----------+------+| id | username | pid |+----+----------+------+| 4 | John | 1 || 5 | Rose | 2 |+----+----------+------+ 可见：子表已自动删除id为３的记录 但因为物理的外键约束只有INNODB引擎才支持，在实际的开发过程中，我们很少使用物理的外键约束，大多使用逻辑的外键约束。所以说，我们在实际的项目开发中，一般定义逻辑的外键，指的是在定义两张表结构时，按照存在的某种结构的方式去定义，但是不使用FOREIGN KEY这个关键词 表级约束和列级约束 如之前创建的外键约束为列级约束，可以在列定义时声明 在实际开发中，用列级约束比较多，表级约束很少用。 修改数据表——添加\\删除列添加单列 ALTER TABLE table_name ADD [COLUMN] col_name colume_definition [FIRST|AFTER col_name] 如： 123456789101112mysql&gt; ALTER TABLE user1 ADD age TINYINT UNSIGNED NOT NULL DEFAULT 10;Query OK, 0 rows affected (0.68 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; SHOW COLUMNS FROM user1;+----------+----------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+----------------+| id | smallint(5) unsigned | NO | PRI | NULL | auto_increment || username | varchar(10) | NO | | NULL | || pid | smallint(5) unsigned | YES | MUL | NULL | || age | tinyint(3) unsigned | NO | | 10 | |+----------+----------------------+------+-----+---------+----------------+ 指定AFTER: 1234567891011121314mysql&gt; ALTER TABLE user1 ADD password VARCHAR(20) NOT NULL AFTER username;Query OK, 0 rows affected (0.76 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; SHOW COLUMNS FROM user1;+----------+----------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+----------------+| id | smallint(5) unsigned | NO | PRI | NULL | auto_increment || username | varchar(10) | NO | | NULL | || password | varchar(20) | NO | | NULL | || pid | smallint(5) unsigned | YES | MUL | NULL | || age | tinyint(3) unsigned | NO | | 10 | |+----------+----------------------+------+-----+---------+----------------+5 rows in set (0.00 sec) 指定FIRST: 123456789101112131415mysql&gt; ALTER TABLE user1 ADD truename VARCHAR(20) NOT NULL FIRST;Query OK, 0 rows affected (0.96 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; SHOW COLUMNS FROM user1;+----------+----------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+----------------+| truename | varchar(20) | NO | | NULL | || id | smallint(5) unsigned | NO | PRI | NULL | auto_increment || username | varchar(10) | NO | | NULL | || password | varchar(20) | NO | | NULL | || pid | smallint(5) unsigned | YES | MUL | NULL | || age | tinyint(3) unsigned | NO | | 10 | |+----------+----------------------+------+-----+---------+----------------+6 rows in set (0.00 sec) 添加多列：（不能指定位置关系） 1ALTER TABLE table_name ADD [COLUMN] (col_name column_definition,...) 删除列 1ALTER TABLE table_name DROP [COLUMN] (col_name) 如： 12345678910111213mysql&gt; ALTER TABLE user1 DROp truename;Query OK, 0 rows affected (0.69 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; SHOW COLUMNS FROM user1;+----------+----------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+----------------+| id | smallint(5) unsigned | NO | PRI | NULL | auto_increment || username | varchar(10) | NO | | NULL | || password | varchar(20) | NO | | NULL | || pid | smallint(5) unsigned | YES | MUL | NULL | || age | tinyint(3) unsigned | NO | | 10 | |+----------+----------------------+------+-----+---------+----------------+ 删除多列 1ALTER TABLE table_name DROP col_name1,DROP col_name2,... 删除同时添加 1ALTER TABLE table_name DROP col_name1,ADD col_name2,... 修改数据表——添加\\删除约束**添加主键约束： 1ALTER TABLE table_name ADD[CONSTRAINT[symbol]] PRIMARY KEY [index_type] (index_col_name,...) 可选项：CONSTRAINT[symbol] 可以为主键设定名字，index_type指定索引类型 如： 1234567891011121314mysql&gt; CREATE TABLE user2( -&gt; username VARCHAR(10) NOT NULL, -&gt; pid SMALLINT UNSIGNED -&gt; );mysql&gt; ALTER TABLE user2 ADD id SMALLINT UNSIGNED;mysql&gt; ALTER TABLE user2 ADD CONSTRAINT PK_user2_id PRIMARY KEY(id);mysql&gt; SHOW COLUMNS FROM user2;+----------+----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+-------+| username | varchar(10) | NO | | NULL | || pid | smallint(5) unsigned | YES | | NULL | || id | smallint(5) unsigned | NO | PRI | NULL | |+----------+----------------------+------+-----+---------+-------+ 添加唯一约束 1ALTER TABLE table_name ADD[CONSTRAINT[symbol]] UNIQUE [INDEX|KEY] [index_name][index_type] (index_col_name,...) 如： 123456789mysql&gt; ALTER TABLE user2 ADD UNIQUE (username);mysql&gt; SHOW COLUMNS FROM user2;+----------+----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+-------+| username | varchar(10) | NO | UNI | NULL | || pid | smallint(5) unsigned | YES | | NULL | || id | smallint(5) unsigned | NO | PRI | NULL | |+----------+----------------------+------+-----+---------+-------+ 添加外键约束 1ALTER TABLE table_name ADD[CONSTRAINT[symbol]] FOREIGN KEY [index_name] (index_col_name,...) reference_definition 如： 1234567891011mysql&gt; ALTER TABLE user2 ADD FOREIGN KEY (pid) PEFERENCES provinces(id);mysql&gt; SHOW CREATE TABLE user2;| user2 | CREATE TABLE `user2` ( `username` varchar(10) NOT NULL, `pid` smallint(5) unsigned DEFAULT NULL, `id` smallint(5) unsigned NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`), KEY `pid` (`pid`), CONSTRAINT `user2_ibfk_1` FOREIGN KEY (`pid`) REFERENCES `provinces` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1 | 添加/删除默认约束 1ALTER TABLE table_name ALTER[COLUMN] col_name &#123;SET DEFAULT literal|DROP DEFAULT&#125; 如添加约束： 1234567891011mysql&gt; ALTER TABLE user2 ADD age TINYINT UNSIGNED NOT NULL;mysql&gt; ALTER TABLE user2 ALTER age SET DEFAULT 15;mysql&gt; SHOW COLUMNS FROM user2;+----------+----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+-------+| username | varchar(10) | NO | UNI | NULL | || pid | smallint(5) unsigned | YES | MUL | NULL | || id | smallint(5) unsigned | NO | PRI | NULL | || age | tinyint(3) unsigned | NO | | 15 | |+----------+----------------------+------+-----+---------+-------+ 删除约束： 12345678910mysql&gt; ALTER TABLE user2 ALTER age DROP DEFAULT;mysql&gt; SHOW COLUMNS FROM user2;+----------+----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+-------+| username | varchar(10) | NO | UNI | NULL | || pid | smallint(5) unsigned | YES | MUL | NULL | || id | smallint(5) unsigned | NO | PRI | NULL | || age | tinyint(3) unsigned | NO | | NULL | |+----------+----------------------+------+-----+---------+-------+ 删除主键约束 1ALTER TABLE table_name DROP PRIMARY KEY 如： 12345678910mysql&gt; ALTER TABLE user2 DROP PRIMARY KEY;mysql&gt; SHOW COLUMNS FROM user2;+----------+----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+-------+| username | varchar(10) | NO | PRI | NULL | || pid | smallint(5) unsigned | YES | MUL | NULL | || id | smallint(5) unsigned | NO | | NULL | || age | tinyint(3) unsigned | NO | | NULL | |+----------+----------------------+------+-----+---------+-------+ 删除唯一约束 1ALTER TABLE table_name DROP &#123;INDEX|KEY&#125; index_name 指定索引名称是因为一张表可以有多个唯一约束，需要删除字段上的约束而非字段本身就要知道约束名称加以限定。 查看索引名称： 1mysql&gt; SHOW INDEXES FROM user2\\G 得到 唯一约束column的Key_name: username 删除约束： 1mysql&gt; ALTER TABLE user2 DROP INDEX username; 查看数据表： 123456789mysql&gt; SHOW COLUMNS FROM user2;+----------+----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+-------+| username | varchar(10) | NO | | NULL | || pid | smallint(5) unsigned | YES | MUL | NULL | || id | smallint(5) unsigned | NO | | NULL | || age | tinyint(3) unsigned | NO | | NULL | |+----------+----------------------+------+-----+---------+-------+ 唯一约束已删除 删除外键约束 1mysql&gt; ALTER TABLE user2 DROP FOREIGN KEY fk_symbol; 需查看外键的fk_symbol（系统指定）： 1234mysql&gt; SHOW CREATE TABLE user2;得到：KEY `pid` (`pid`), CONSTRAINT `user2_ibfk_1` FOREIGN KEY (`pid`) REFERENCES `provinces` (`id`) 即：fk_symbol为‘user2_ibfk_1’ 删除约束： 1mysql&gt; ALTER TABLE user2 DROP FOREIGN KEY user2_ibfk_1; 还可以继续删除索引： 123mysql&gt; ALTER TABLE user2 DROP INDEX pid;mysql&gt; SHOW INDEXES FROM user2\\GEmpty set (0.00 sec) 修改列定义和更名数据表修改列定义 1ALTER TABLE table_name MODIFY col_name column_definition [FIRST|AFTER col_name] 备选项：可以修改字段位置，如： 12345678910mysql&gt; ALTER TABLE user2 MODIFY id SMALLINT UNSIGNED NOT NULL FIRST;mysql&gt; SHOW COLUMNS FROM user2;+----------+----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+-------+| id | smallint(5) unsigned | NO | | NULL | || username | varchar(10) | NO | | NULL | || pid | smallint(5) unsigned | YES | | NULL | || age | tinyint(3) unsigned | NO | | NULL | |+----------+----------------------+------+-----+---------+-------+ 修改字段数据类型： 12345678910mysql&gt; ALTER TABLE user2 MODIFY id TINYINT UNSIGNED NOT NULL;mysql&gt; SHOW COLUMNS FROM user2;+----------+----------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+----------------------+------+-----+---------+-------+| id | tinyint(3) unsigned | NO | | NULL | || username | varchar(10) | NO | | NULL | || pid | smallint(5) unsigned | YES | | NULL | || age | tinyint(3) unsigned | NO | | NULL | |+----------+----------------------+------+-----+---------+-------+ 但注意：将数据类型修改为更小类型时可能会造成数据丢失。 修改列名称： 1ALTER TABLE table_name CHANGE old_col_name new_col_name column_definition [FIRST|AFTER col_name] 即可修改列名称，也可修改列定义。 如： 12345678910mysql&gt; ALTER TABLE user2 CHANGE pid p_id TINYINT UNSIGNED NOT NULL;mysql&gt; SHOW COLUMNS FROM user2;+----------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+---------------------+------+-----+---------+-------+| id | tinyint(3) unsigned | NO | | NULL | || username | varchar(10) | NO | | NULL | || p_id | tinyint(3) unsigned | NO | | NULL | || age | tinyint(3) unsigned | NO | | NULL | |+----------+---------------------+------+-----+---------+-------+ 数据表更名 123ALTER TABLE table_name RENAME[TO|AS] new_table_name或：RENAME TABLE table_name TO new_table_name 如： 1234567891011121314151617181920212223242526272829303132mysql&gt; ALTER TABLE user2 RENAME user3;mysql&gt; SHOW TABLES;+-----------------+| Tables_in_lcyDB |+-----------------+| provinces || tb1 || tb2 || tb3 || tb4 || tb5 || tb6 || user1 || user3 || users |+-----------------+mysql&gt; ALTER TABLE user3 RENAME user2;mysql&gt; SHOW TABLES;+-----------------+| Tables_in_lcyDB |+-----------------+| provinces || tb1 || tb2 || tb3 || tb4 || tb5 || tb6 || user1 || user2 || users |+-----------------+ 注意： 要尽量少使用列和表的更名，如果之前创建了索引或视图，引用了表名或列名，修改名称可能会导致视图或存储过程无法正常工作。","tags":[]},{"title":"MySQL-学习笔记-2","date":"2017-04-13T10:12:57.000Z","path":"2017/04/13/MySQL-学习笔记-2/","text":"数据类型及数据表操作数据类型数据类型决定存储格式 要根据实际应用来选择最合适的数据类型 整型 浮点型 日期时间型 通常用数字类型取代日期时间或进行时间戳转换 字符型 注： CHAR(M)为定长类型 VARCHAR 为变长类型 L+1或L+2里多出来的字节用来保存数据值长度 ENUM表示从枚举的值中选择其一 SET表示从成员中进行排列组合形成其值 数据表操作创建数据表数据表是数据库中其他对象的基础 关系性数据库——二维表格——数据表 行——记录 列——字段 打开数据库 USE 数据库名称; SELECT DATABASE()； 显示当前使用的数据库 创建数据表 CREATE TABLE table_name( ​ column_name data_type, ​ …… ) e.g. 123456&gt; mysql&gt; CREATE TABLE tb1(&gt; -&gt; username VARCHAR(20),&gt; -&gt; age TINYINT UNSIGNED,&gt; -&gt; salary FLOAT(8,2) UNSIGNED &gt; -&gt; );&gt; &gt; Query OK, 0 rows affected (0.35 sec) 查看数据表 **SHOW TABLES[FROM db_name] [LIKE ‘pattern’| WHERE expr] 注：此命令可查询其他数据库中的表且不改变当前所处数据库，如： mysql&gt; show tables from mysql; +—————————+ | Tables_in_mysql |+—————————+| columns_priv || db || engine_cost || event | 第二行涉及通配符，暂略 查看数据表结构 SHOW COLUMNS FROM table_name; 如： mysql&gt; show columns from tb1;+———-+———————+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+———-+———————+——+—–+———+——-+| username | varchar(20) | YES | | NULL | || age | tinyint(3) unsigned | YES | | NULL | || salary | float(8,2) unsigned | YES | | NULL | |+———-+———————+——+—–+———+——-+3 rows in set (0.01 sec) 记录插入与查找插入记录 INSERT [INTO] tb1_name [(col_name,…)] VALUES(val,…) 如： mysql&gt; INSERT tb1 VALUES(‘TOM’,25,7825.37);Query OK, 1 row affected (0.07 sec) mysql&gt; INSERT tb1(username,salary) VALUES(‘Jphn’,6825.37);Query OK, 1 row affected (0.04 sec) 查找记录 SELECT expr,… FROM table_name 如： mysql&gt; SELECT * FROM tb1;+———-+——+———+| username | age | salary |+———-+——+———+| TOM | 25 | 7825.37 || Jphn | NULL | 6825.37 |+———-+——+———+ 注：*是对字段的过滤而非对记录的过滤 空值与非空创建表格时指定某字段的值是否可以为空： NULL,字段值可以为空 NOT NULL，字段值禁止为空 mysql&gt; CREATE TABLE tb2(-&gt; username VARCHAR(20) NOT NULL,-&gt; age TINYINT UNSIGNED NULL-&gt; ); mysql&gt; SHOW COLUMNS FROM tb2;+———-+———————+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+———-+———————+——+—–+———+——-+| username | varchar(20) | NO | | NULL | || age | tinyint(3) unsigned | YES | | NULL | |+———-+———————+——+—–+———+——-+ mysql&gt; INSERT tb2 VALUES(NULL,26);ERROR 1048 (23000): Column ‘username’ cannot be null 自动编号保证某条记录的唯一性——记录自动编号 即自动编号字段必须定义为数值类型，且定义为主键 如设计错误的定义： mysql&gt; CREATE TABLE tb3( -&gt; -&gt;id SMALLINT UNSIGNED AUTO_INCREMENT, -&gt; username VARCHAR(30) NOT NULL -&gt;); ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key 初涉主键约束 如修改上述记录： 123mysql&gt; CREATE TABLE tb3(-&gt; id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,-&gt; username VARCHAR(30) NOT NULL -&gt; ); mysql&gt; SHOW COLUMNS FROM tb3;+———-+———————-+——+—–+———+—————-+| Field | Type | Null | Key | Default | Extra |+———-+———————-+——+—–+———+—————-+| id | smallint(5) unsigned | NO | PRI | NULL | auto_increment || username | varchar(30) | NO | | NULL | |+———-+———————-+——+—–+———+—————-+ 自动编号示例： mysql&gt; INSERT tb3(username) VALUES(‘XueXue’);Query OK, 1 row affected (0.05 sec) mysql&gt; INSERT tb3(username) VALUES(‘TuTu’);Query OK, 1 row affected (0.06 sec) mysql&gt; INSERT tb3(username) VALUES(‘JingJing’);Query OK, 1 row affected (0.02 sec) mysql&gt; INSERT tb3(username) VALUES(‘GaiGai’);Query OK, 1 row affected (0.05 sec) mysql&gt; SELECT * FROM tb3;+—-+———-+| id | username |+—-+———-+| 1 | XueXue || 2 | TuTu || 3 | JingJing || 4 | GaiGai |+—-+———-+ 主键不一定要定义为自动编号，如： mysql&gt; CREATE TABLE tb4(-&gt; id SMALLINT UNSIGNED PRIMARY KEY,-&gt; username VARCHAR(20) NOT NULL-&gt; );Query OK, 0 rows affected (0.36 sec) mysql&gt; SHOW COLUMNS FROM tb4;+———-+———————-+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+———-+———————-+——+—–+———+——-+| id | smallint(5) unsigned | NO | PRI | NULL | || username | varchar(20) | NO | | NULL | |+———-+———————-+——+—–+———+——-+ 主键字段具有唯一性： mysql&gt; INSERT tb4 VALUES(22,’Tom’);Query OK, 1 row affected (0.05 sec) mysql&gt; INSERT tb4 VALUES(22,’John’);ERROR 1062 (23000): Duplicate entry ‘22’ for key ‘PRIMARY’ 初涉唯一约束 第二三条看似相悖，实际上一张表只允许存在一个值为空的唯一约束字段 创建示例： 12345mysql&gt; CREATE TABLE tb5(-&gt; id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,-&gt; username VARCHAR(20) NOT NULL UNIQUE KEY,-&gt; age TINYINT UNSIGNED-&gt; ); mysql&gt; SHOW COLUMNS FROM tb5;+———-+———————-+——+—–+———+—————-+| Field | Type | Null | Key | Default | Extra |+———-+———————-+——+—–+———+—————-+| id | smallint(5) unsigned | NO | PRI | NULL | auto_increment || username | varchar(20) | NO | UNI | NULL | || age | tinyint(3) unsigned | YES | | NULL | |+———-+———————-+——+—–+———+—————-+ 验证唯一性： mysql&gt; INSERT tb5(username,age) VALUES(‘John’,22);Query OK, 1 row affected (0.05 sec) mysql&gt; INSERT tb5(username,age) VALUES(‘John’,22);ERROR 1062 (23000): Duplicate entry ‘John’ for key ‘username’ 初涉默认约束DEFAULT 创建： mysql&gt; CREATE TABLE tb6(-&gt; id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,-&gt; username VARCHAR(20) NOT NULL UNIQUE KEY,-&gt; sex ENUM(‘1’,’2’,’3’) DEFAULT ‘3’-&gt; ); 查看： mysql&gt; SHOW COLUMNS FROM tb6;+———-+———————-+——+—–+———+—————-+| Field | Type | Null | Key | Default | Extra |+———-+———————-+——+—–+———+—————-+| id | smallint(5) unsigned | NO | PRI | NULL | auto_increment | username varchar(20) NO UNI NULL | sex | enum(‘1’,’2’,’3’) | YES | | 3 | |+———-+———————-+——+—–+———+—————-+ 验证默认约束： mysql&gt; INSERT tb6(username) VALUES(‘Tom’);Query OK, 1 row affected (0.05 sec) mysql&gt; SELECT * FROM tb6;+—-+———-+——+| id | username | sex |+—-+———-+——+| 1 | Tom | 3 |+—-+———-+——+","tags":[]},{"title":"MySQL-学习笔记-1","date":"2017-04-10T16:17:20.000Z","path":"2017/04/11/MySQL-学习笔记-1/","text":"MySQL自启动sudo chkconfig –add mysql 添加服务 netstat -na | grep 3306 看到有监听说明服务启动 或：ps -ef | grep mysqld 检查MySQL服务器是否启动 另： sudo /etc/init.d/mysql start 启动MySQL 服务器 sudo /etc/init.d/mysql stop 或 ./mysqladmin -u root -p shutdown 关闭目前运行的 MySQL 服务器（/usr/bin 目录下） MySQL添加用户、删除用户与授权登录MYSQL： >mysql -u root -p 创建用户： >CREATE USER ‘username’@’localhost’ IDENTIFIED BY ‘password’; 或 INSERT INTO user (host, user,ssl_cipher,x509_issuer,x509_subject) VALUES (‘localhost’, ‘test’,’’,’’,’’); use mysql; UPDATE user SET authentication_string=PASSWORD(‘*‘) WHERE user=’test’; FLUSH PRIVILEGES; 为用户授权: 以ROOT身份登录 >mysql -u root -p 为用户创建一个数据库: >create database *DB; 授权新用户拥有***DB数据库的所有权限: >grant all privileges on ***DB. to \\**@localhost identified by ‘*(password)’; 刷新系统权限表: >flush privileges; 授权新用户拥有所有数据库的某些权限： >grant select,delete,update,create,drop on . to ***@localhost identified by “*“; 查看MYSQL数据库中所有用户: > SELECT DISTINCT CONCAT(‘User: ‘’’,user,’’’@’’’,host,’’’;’) AS query FROM mysql.user; 查看数据库中具体某个用户的权限: >show grants for ‘*‘@’localhost’; 修改MySQL提示符：登录时： mysql -u -p –prompt 提示符 已连接客户端时: >prompt 提示符; 部分参数： 常用命令及语法规范 操作数据库创建数据库： >CREATE DATABASE db_name; 全部参数： 存在warning信息时查看： >SHOW WARNINGS; 查看创建时编码方式： >SHOW CREATE DATABASE db_name; 查看（当前服务器下）数据库列表： >SHOW DATABASES; 修改数据库： 删除数据库： >DROP DATABASE db_name;","tags":[]},{"title":"t检验笔记","date":"2017-04-09T08:17:21.000Z","path":"2017/04/09/t检验笔记/","text":"t检验_第二部分效应量（effect size）实验性研究中，表示处理效应的大小 非实验性研究中，表示变量之间关系强度 t/z检验中效应量衡量指标——均值差异（mean difference） 效应量测量类型差异度量​ 均值差异 ​ 标准化差异度量（standardized differens）——cohen‘s d 相关度量​ $$r^2$$ 表示某个变量的变化比例与另一个变量的关系（一个变量能够“解释”另一个变量的特定变化的比例） 统计显著性在统计学中，“显著性”是指—— rejected the null results are not likely due to chance（sampling error） 即：我们在解释结果时，排除了随机因素/抽样错误 判断调查研究结果是否有意义： 变量是否具有实际意义或社会、理论意义 效应量大小 能否排除抽样错误 能否排除结果对立解释（排除潜在变量影响） Cohen‘s d【标准化均值差异（standardized mean difference）】$$d=\\frac{\\bar x-\\mu}{s}$$ $$x 表示样本均值 ,s表示样本标准差$$ $r^2$ （确定系数）​ 相关度量 表示两个变量之间的关系程度 ​ $$r^2$$ 范围：0~1（数值越大相关性越强） ​ t检验 中计算 $$r^2$$ : ​ $$r^2=\\frac{t^2}{t^2+ df}$$ t为在t检验中获得的值，df为自由度 报告结果描述统计量（文，图，表） 推论统计量（假设检验、置信区间） APA style ​ $$t（df）=x.xx,p=x.xx,direction$$ ​ e.g. $$t(24)=-2.50,p&lt;0.05,one-tailed$$ 报告置信区间：（注明是什么的置信区间） ​ e.g. confidence interval on the mean difference;95% CI=(4,6) 报告效应量： e.g. $$d=x.xx$$ ​ $$r^2=.xx$$ (通常不写0) 完整的单样本t检验t检验置信区间Cohen‘s dr^2公式： ​ $$df=n-1$$ ​ $$SEM(均值标准误差)=\\frac{S}{\\sqrt{n}}$$ ​ $$t=\\frac{x-\\mu}{SEM}$$ ​ $$CI =x+/-margin\\ of\\ error $$ ​ $$margin\\ of\\ error=t_crttical*SEM$$ ​ $$Cohen’s\\ d=\\frac{x-\\mu}{S}$$ ​ $$r^2=\\frac{t^2}{t^2+ df}$$ 过程 自变量、因变量 处理方式 零假设、对立假设 哪种尾检验 自由度 t临界值$$(\\alpha 水平)$$ SEM 均值误差（$$x-\\mu$$） t统计量 t是否在临界区 p值范围（是否大于置信水平） 统计显著性（是/否） 结果是否有意义 Cohen’s d $$r^2$$ 误差范围 置信区间 ​","tags":[]},{"title":"Hello World","date":"2017-04-08T16:00:00.000Z","path":"2017/04/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]