---
title: 《利用Python进行数据分析》笔记——NUmPy基础
date: 2017-05-07 14:39:59
tags:
categories: 数据分析
---

#### 创建ndarray

NumPy的empty方法可以用来创建数组（返回一些未初始化的值）

```
In [2]:
np.empty((2,3))
Out[2]:
array([[  0.00000000e+000,   7.48378625e-317,   6.92605451e-310],
       [  6.92604876e-310,   0.00000000e+000,   0.00000000e+000]])
```

arange是Python内置函数range的array版：

```
np.arange(15)
Out[4]:
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
```

<!---more--->

#### 数据类型

可以通过ndarray的astype方法显示地转换dtype：

```
In [6]:
arr=np.arange(5)
arr.dtype
Out[6]:
dtype('int64')
In [8]:
float_arr=arr.astype(np.float64)
float_arr
Out[8]:
array([ 0.,  1.,  2.,  3.,  4.])
In [9]:
float_arr.dtype
Out[9]:
dtype('float64')
```

调用astype会创建一个新的数组。

#### 索引、切片

ndarray中的数据切片是原始数组的视图——即数据不会被复制，视图上的任何修改将直接反映到源数组上。

```
In [13]:
arr=np.arange(10)
arr_slice=arr[5:8]
arr_slice[0]=123
arr
Out[13]:
array([  0,   1,   2,   3,   4, 123,   6,   7,   8,   9])
In [14]:
arr_slice[:]=0
arr
Out[14]:
array([0, 1, 2, 3, 4, 0, 0, 0, 8, 9])
```

选取数据的子集也是视图,除非使用显式的复制操作：

```
In [25]:
arr1d=arr2d[0]
arr1d[:]=0
arr2d
Out[25]:
array([[0, 0, 0],
       [4, 5, 6],
       [7, 8, 9]])
In [27]:
arr1d=arr2d[0].copy()
arr1d[:]=0
arr2d
Out[27]:
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
```

#### 布尔型索引

```
In [43]:
from numpy.random import randn
data=randn(7,4)
data
Out[43]:
array([[-0.08217433,  0.72757825, -0.17572698,  0.11375411],
       [ 0.14297017,  0.37876047,  1.69723883, -0.76684935],
       [ 0.19313528,  0.48533314, -0.55429606,  0.04060214],
       [ 0.72773502, -0.7296657 , -0.04213444,  0.21005464],
       [ 0.6785969 ,  0.28481481, -0.34063399,  0.34345932],
       [-0.76815318, -0.60921259,  1.69758231,  0.51980305],
       [-1.97113938, -0.13498346, -1.79160841,  0.086466  ]])
In [44]:
bl=np.array([True,False,False,True,False,False,False])
data[bl,2:]
Out[44]:
array([[-0.17572698,  0.11375411],
       [-0.04213444,  0.21005464]])
In [45]:
data[~bl,2:]
Out[45]:
array([[ 1.69723883, -0.76684935],
       [-0.55429606,  0.04060214],
       [-0.34063399,  0.34345932],
       [ 1.69758231,  0.51980305],
       [-1.79160841,  0.086466  ]])
```

#### Fancy index（花式索引）

可以利用整数数组进行索引：

```
In [50]:
arr=np.empty((8,4))
for i in range(8):
    arr[i]=i
arr[[4,3,0,6]]
Out[50]:
array([[ 4.,  4.,  4.,  4.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 6.,  6.,  6.,  6.]])
```

使用np.ix_函数，将两个一维整数数组转换为一个用于选取矩形区域的索引器：

```
In [56]:
arr=np.arange(32).reshape(8,4)
arr
Out[56]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
In [58]:
arr[np.ix_([1,5,7,2],[0,3,1,2])]
Out[58]:
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
```

等同于：

```
arr[[1,5,7,2]][:,[0,3,1,2]]
```
#### 通用函数

ufunc——一种对ndarray中数据执行元素级运算的函数

一元ufunc：

```
In [19]:
a=randn(10)
a
Out[19]:
array([-0.31537852,  2.32341427,  0.56449346,  1.024455  , -0.32593332,
        0.42131887,  0.25607879, -0.4078455 ,  0.83566915,  0.10110313])
In [20]:
print np.sign(a) #求个元素正负号
print np.ceil(a) #向上取整
print np.floor(a) #向下取整
print np.rint(a) #四舍五入
print np.modf(a) #将元素的小数和整数部分以两个独立数组的形式返回
[-1.  1.  1.  1. -1.  1.  1. -1.  1.  1.]
[-0.  3.  1.  2. -0.  1.  1. -0.  1.  1.]
[-1.  2.  0.  1. -1.  0.  0. -1.  0.  0.]
[-0.  2.  1.  1. -0.  0.  0. -0.  1.  0.]
(array([-0.31537852,  0.32341427,  0.56449346,  0.024455  , -0.32593332,
        0.42131887,  0.25607879, -0.4078455 ,  0.83566915,  0.10110313]), array([-0.,  2.,  0.,  1., -0.,  0.,  0., -0.,  0.,  0.]))
```

二元ufunc：

```
a=np.array([1.0,2.0,3.0])
b=np.array([3,2,1])
print np.add(a,b)
print np.subtract(a,b)
print np.multiply(a,b)
print np.divide(a,b)
print np.floor_divide(a,b) #整除
print np.power(a,b) #元素级计算a的b次幂
print np.maximum(a,b) #计算元素级最大值
print np.greater(a,b) #元素级比较运算，产生布尔型数组
[ 4.  4.  4.]
[-2.  0.  2.]
[ 3.  4.  3.]
[ 0.33333333  1.          3.        ]
[ 0.  1.  3.]
[ 1.  4.  3.]
[ 3.  2.  3.]
[False False  True]
```

> 比较运算函数还包括greater_equal,less,less_equal,equal,not_equal

#### 矢量化数组运算

用数组表达式替代循环

例如：在一组值上计算函数sqrt(x^2+y^2)

```
points=np.arange(-5,5,0.01) #生成1000个间隔相等的点
xs,ys=np.meshgrid(points,points) #接受一个一维数组，产生两个二维矩阵(对应所有（x，y）对)
```

如：

```
points=np.arange(-5,5,1)
xs,ys=np.meshgrid(points,points)
print xs
print ys
[[-5 -4 -3 -2 -1  0  1  2  3  4]
 [-5 -4 -3 -2 -1  0  1  2  3  4]
 [-5 -4 -3 -2 -1  0  1  2  3  4]
 [-5 -4 -3 -2 -1  0  1  2  3  4]
 [-5 -4 -3 -2 -1  0  1  2  3  4]
 [-5 -4 -3 -2 -1  0  1  2  3  4]
 [-5 -4 -3 -2 -1  0  1  2  3  4]
 [-5 -4 -3 -2 -1  0  1  2  3  4]
 [-5 -4 -3 -2 -1  0  1  2  3  4]
 [-5 -4 -3 -2 -1  0  1  2  3  4]]
[[-5 -5 -5 -5 -5 -5 -5 -5 -5 -5]
 [-4 -4 -4 -4 -4 -4 -4 -4 -4 -4]
 [-3 -3 -3 -3 -3 -3 -3 -3 -3 -3]
 [-2 -2 -2 -2 -2 -2 -2 -2 -2 -2]
 [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
 [ 0  0  0  0  0  0  0  0  0  0]
 [ 1  1  1  1  1  1  1  1  1  1]
 [ 2  2  2  2  2  2  2  2  2  2]
 [ 3  3  3  3  3  3  3  3  3  3]
 [ 4  4  4  4  4  4  4  4  4  4]]
```

```
%matplotlib inline
import matplotlib.pyplot as plt
z=np.sqrt(xs**2+ys**2) #矢量化数组运算
plt.imshow(z,cmap=plt.cm.winter) #绘制灰度图
plt.colorbar() #添加colorbar
```

![](Numpy笔记补充\1.png)



#### 条件逻辑与数组运算

np.where是三元表达式x if condition else y的矢量化版本

```
xarr=np.array([1,2,3,4,5])
yarr=np.array([6,7,8,9,0])
cond=np.array([True,False,True,False,True])
result=np.where(cond,xarr,yarr)
result
Out：
array([1, 7, 3, 9, 5])
```

第二、三个参数也可以为标量值：

```
In [101]:
arr
arr=randn(3,3)
arr
Out[101]:
array([[-0.54424131,  0.62863098,  0.56891827],
       [ 1.34643462,  1.56380868,  0.58623083],
       [ 0.43735038,  0.44985456, -0.34077432]])
In [102]:
np.where(arr>0,1,-1)
Out[102]:
array([[-1,  1,  1],
       [ 1,  1,  1],
       [ 1,  1, -1]])
In [104]:
np.where(arr>0,1,arr)
Out[104]:
array([[-0.54424131,  1.        ,  1.        ],
       [ 1.        ,  1.        ,  1.        ],
       [ 1.        ,  1.        , -0.34077432]])
```

#### 统计方法

求元素累积和：

```
arr=np.array([[0,1,2],[3,4,5],[6,7,8]])
In [115]:
arr.cumsum()
Out[115]:
array([ 0,  1,  3,  6, 10, 15, 21, 28, 36])
```

可以指定在某轴上累积：

```
arr.cumsum(axis=1) 
Out[110]:
array([[ 0,  1,  3],
       [ 3,  7, 12],
       [ 6, 13, 21]])       
arr.cumprod(0) #求累计积
Out[114]:
array([[ 0,  1,  2],
       [ 0,  4, 10],
       [ 0, 28, 80]])
```

#### 排序

默认沿横轴升序排列：

```
arr=randn(3,5)
arr
Out[31]:
array([[-0.22762911, -0.59528567, -0.44706287, -0.65593567, -1.24890433],
       [-0.77928573, -0.56997516,  0.37210553,  0.83965676,  0.54670066],
       [ 1.8469569 ,  0.54329902, -1.19774885,  0.69641988,  0.43255057]])
In [32]:
arr.sort()
arr
Out[32]:
array([[-1.24890433, -0.65593567, -0.59528567, -0.44706287, -0.22762911],
       [-0.77928573, -0.56997516,  0.37210553,  0.54670066,  0.83965676],
       [-1.19774885,  0.43255057,  0.54329902,  0.69641988,  1.8469569 ]])
```

指定在某轴上排序：

```
arr=randn(3,5)
arr
array([[ 0.76745725,  0.63957621,  0.54959643, -1.15530712,  1.49122891],
       [ 0.42202383,  0.2410772 , -0.4189283 ,  0.94238709,  0.26250363],
       [-0.13254626, -1.25501108, -0.45683496, -1.52373513,  0.28402619]])
arr.sort(0) #在纵轴上排序
arr
array([[-0.13254626, -1.25501108, -0.45683496, -1.52373513,  0.26250363],
       [ 0.42202383,  0.2410772 , -0.4189283 , -1.15530712,  0.28402619],
       [ 0.76745725,  0.63957621,  0.54959643,  0.94238709,  1.49122891]])
arr.sort(1) #在横轴上排序
arr
Out[79]:
array([[-1.52373513, -1.25501108, -0.45683496, -0.13254626,  0.26250363],
       [-1.15530712, -0.4189283 ,  0.2410772 ,  0.28402619,  0.42202383],
       [ 0.54959643,  0.63957621,  0.76745725,  0.94238709,  1.49122891]])
```

降序排列：

```
arr.sort(0)
arr=arr[::-1]
arr
Out[87]:
array([[ 1.13964135,  0.88074008,  0.96757798,  1.42249469,  1.12209403],
       [-0.45274363,  0.00309309,  0.2147203 ,  0.40488698,  0.17494692],
       [-0.81773678, -0.39659417, -0.38647118, -0.53779886, -1.46781707]])
```

#### 文件存取

读取csv文本：

```
path='/home/milhaven1733/Desktop/Data Analyst/pydata-book-master/ch04/array_ex.txt'
arr=np.loadtxt(path,delimiter=',')
arr
Out[16]:
array([[ 0.580052,  0.18673 ,  1.040717,  1.134411],
       [ 0.194163, -0.636917, -0.938659,  0.124094],
       [-0.12641 ,  0.268607, -0.695724,  0.047428],
       [-1.484413,  0.004176, -0.744203,  0.005487],
       [ 2.302869,  0.200131,  1.670238, -1.88109 ],
       [-0.19323 ,  1.047233,  0.482803,  0.960334]])
```

#### 线性代数

```
x=randn(2,2)
mat=x.T.dot(x) #x的转秩与x的点积运算
inv(mat)
mat.dot(inv(mat)) #mat点乘mat的逆
Out[159]:
array([[ 1.,  0.],
       [ 0.,  1.]])
```

#### 随机数与数组运算范例：随机漫步

```
%matplotlib inline
import matplotlib.pyplot as plt
nsteps=1000 
draws=np.random.randint(0,2,size=nsteps)  #产生1000个（0,2）之间的整数，即为0或为1
steps=np.where(draws>0,1,-1) #将1,0转化为1，-1
walk=steps.cumsum()  #计算累积和
plt.plot(walk) #绘图
```

![](Numpy笔记补充\2.png)

模拟多个随机漫步过程：

```
nwalks=100 #模拟100个随机过程
nsteps=100
draws=np.random.randint(0,2,size=(nwalks,nsteps))
steps=np.where(draws>0,1,-1)
walks=steps.cumsum(1)
```

计算到达15或-15的最小穿越时间:

```
hist=(np.abs(walks)>=15).any(1)  #检查每个漫步过程是否到达(-)15，返回布尔型array，1指定在每行上检查
crossing_time=(np.abs(walks[hist])>=15).argmax(1) #在到达指定值的漫步过程中检查第一次到达的索引值
crossing_time.mean() #计算均值
```